
# Внешние ключи и объединение таблиц

## Внешние ключи. Установка связей между таблицами.

Создадим две таблицы - `customers` и `orders`. Обратите внимание, что у обеих таблиц указано поле `id` - уникальный идентификатор. Также у него стоит свойство `AUTOINCREMENT` - оно автоматически выставляет новое значение, которое больше на единицу, чем значение в предыдущей записи. Это избавляет нас от необходимости вручную выставлять `id` для каждой новой записи.

```python
from sqlite3 import connect

# Создаем базу данных и устанавливаем соединение
with connect('database.db') as connection:
    cur = connection.cursor()

    # Создаем таблицу "customers"
    cur.execute('''CREATE TABLE IF NOT EXISTS customers (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT,
        city TEXT,
        sex TEXT
    );''')

    # Создаем таблицу "orders"
    cur.execute('''CREATE TABLE IF NOT EXISTS orders (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        customer_id INTEGER,
        total REAL,
        FOREIGN KEY (customer_id) REFERENCES customers (id)
    );''')

    # Подтверждаем изменения в базе данных
    connection.commit()
```

Также в таблице orders присутствует новое для вас поле - `FOREIGN KEY(customer_id) REFERENCES customers(id)`, которое используется для создания связи (внешнего ключа) между двумя таблицами. Он указывает, что значения в столбце текущей таблицы (в данном случае `customer_id` в таблице orders) должны быть ссылками на значения в столбце другой таблицы (в данном случае `id` в таблице `customers`):

- `customer_id` - это столбец в таблице orders, который будет содержать ссылки на значения столбца id в таблице users.
    
- `customers(id)` - указывает, что связь будет установлена с таблицей `users` и столбцом `id` в ней.

Таким образом, поле `user_id` в таблице `orders` будет содержать только те значения, которые существуют в столбце `id` таблицы `users`. Если вы попытаетесь вставить значение в поле `user_id`, которого нет в столбце `id` таблицы `users`, будет сгенерировано исключение или ошибка, в зависимости от настроек базы данных.

В результате использования внешнего ключа, вы можете создавать связи между таблицами и выполнять операции, такие как обновление, удаление или выборка данных из связанных таблиц, чтобы получить целостность и связность данных.

---

Теперь напишем скрипт, который будет заполнять базу данных случайными пользователями и заказами:

```python
from sqlite3 import connect
from random import randint, choice

# Создаем списки имен для мужчин и женщин
male_names = ["Александр", "Дмитрий", "Михаил", "Андрей", "Сергей", "Иван", "Алексей", "Виктор", "Николай", "Олег",
              "Артем", "Владимир"]
female_names = ["Анна", "Елена", "Ольга", "Ирина", "Наталья", "Мария", "Татьяна", "Юлия", "Екатерина", "Ксения",
                "Алина", "Полина"]

# Создаем список городов
cities = ["Астана", "Алматы", "Шымкент", "Караганда", "Актау", "Атырау", "Актобе", "Тараз", "Усть-Каменогорск", "Павлодар",
          "Костанай", "Кызылорда", "Семей", "Уральск", "Туркестан", "Кокшетау", "Талдыкорган", "Аксай", "Рудный", "Темиртау",
          "Экибастуз", "Жезказган", "Сарыагаш", "Жанаозен", "Риддер"]

# Создаем список заказов
orders = []

# Генерируем 200 случайных заказов
for order_id in range(1, 201):
    customer_id = randint(1, 25)  # Случайно выбираем идентификатор клиента от 1 до 25
    total = round(randint(50, 500) + randint(0, 99) / 100, 2)  # Случайно генерируем общую стоимость заказа
    orders.append((order_id, customer_id, total))

# Создаем базу данных и устанавливаем соединение
with connect('database.db') as connection:
    cur = connection.cursor()

    # Заполняем таблицу "customers" данными
    for customer_id in range(1, 26):
        if customer_id % 2 == 0:
            name = choice(female_names)
            sex = "Женский"
        else:
            name = choice(male_names)
            sex = "Мужской"
        city = choice(cities)
        cur.execute("INSERT INTO customers (id, name, city, sex) VALUES (?, ?, ?, ?)",
                    (customer_id, name, city, sex))

    # Заполняем таблицу "orders" данными
    for order in orders:
        cur.execute("INSERT INTO orders (id, customer_id, total) VALUES (?, ?, ?)", order)

    # Подтверждаем изменения в базе данных
    connection.commit()
```

## Оператор JOIN

Оператор `JOIN` в SQL используется для объединения данных из двух или более таблиц на основе совпадающих значений в указанных столбцах. Он позволяет комбинировать строки из разных таблиц в один результат, основываясь на заданных условиях соединения. Запрос с JOIN в связке с SELECT выглядит следующим образом:

```sql
SELECT name, city, sex, total
FROM customers
JOIN orders ON customers.id=orders.customer_id;
```

Давайте разберем каждую строчку запроса:

- ```SELECT name, city, sex, total``` - Эта часть указывает, какие столбцы вы хотите выбрать из объединенных таблиц. Здесь вы выбираете столбцы `name`, `city`, `sex` из таблицы `customers` и столбец `total` из таблицы `orders`. 

    Важно заметить, что если в ваших таблицах будут дублироваться названия полей, то следует указать в префиксе название таблицы. Так выглядел бы запрос, если бы в таблице `orders` существовало поле `city`:

    ```sql
    SELECT name, customers.city, sex, total, orders.city
    ```

- ```FROM customers``` - Указывает, что первая таблица, которую мы используем для объединения.

- ```JOIN orders ON customers.id=orders.customer_id;``` - Эта часть указывает, что мы объединяем таблицу `orders` с таблицей `customers` на основе условия равенства `customers.id=orders.customer_id`. То есть, строки будут объединены, когда значения столбца `id` в таблице `customers` совпадают со значениями столбца `customer_id` в таблице `orders`.

## JOIN с функциями агрегации, группировкой и сортировкой

> Следующие запросы сложно переварить, не понимая как работают функции агрегации, группировки и сортировка. Если есть проблемы с их пониманием, то прочтите еще раз статью, посвященную им!

Для начала, попробуем вывести сумму денег, потраченных каждым покупателем:

```sql
SELECT customers.name, SUM(orders.total) AS total_sum
FROM customers
JOIN orders ON customers.id = orders.customer_id
GROUP BY customers.id;
```

Разберем данный запрос:

- `SELECT customers.name, SUM(orders.total) AS total_sum` - Мы начинаем запрос с оператора `SELECT`, указывая столбцы, которые мы хотим выбрать. В данном случае, мы выбираем name из таблицы `customers` и сумму `total` из таблицы `orders`. Мы также используем `AS` для переименования столбца суммы заказов в `total_sum`.

- `FROM customers` - Здесь мы указываем, из какой таблицы мы выбираем данные. В данном случае, мы выбираем данные из таблицы `customers`.

- `JOIN orders ON customers.id = orders.customer_id`: Мы используем оператор JOIN для объединения таблиц `customers` и `orders`. Указываем `ON`, чтобы задать условие объединения. В данном случае, мы объединяем таблицы по поле `id` из `customers` и полю `customer_id` из `orders`.

- `GROUP BY customers.id`: Мы используем оператор GROUP BY для группировки результатов по полю `id` из таблицы `customers`. Это означает, что строки будут сгруппированы по уникальным значениям `id` покупателей.

---

Похожий запрос, который позволит увидеть сумму потраченных денег для каждого пола:

```sql
SELECT customers.sex, SUM(orders.total) AS total_spent
FROM customers
JOIN orders ON customers.id = orders.customer_id
GROUP BY customers.sex;
```

---

Получить список всех покупателей вместе с информацией о количестве сделанных ими заказов:

```sql
SELECT customers.id, customers.name, COUNT(orders.id) AS order_count
FROM customers
LEFT JOIN orders ON customers.id = customer_id
GROUP BY customers.id;
```

---

Сколько денег потратили в определенном городе:

```sql
SELECT city, SUM(orders.id) AS order_count
FROM customers
LEFT JOIN orders ON customers.id = customer_id
GROUP BY city;
```

## INNER, LEFT, RIGHT, FULL JOIN

Разные виды оператора `JOIN` предоставляют различные способы объединения данных из нескольких таблиц. Каждый вид `JOIN` имеет свою специфику и применяется в разных сценариях в зависимости от требуемого результата.

### INNER JOIN (внутреннее объединение, используется по умолчанию):

`INNER JOIN` объединяет строки из двух таблиц только тогда, когда условие соответствия выполняется.
Результатом `INNER JOIN` является набор строк, которые удовлетворяют условию соответствия.
Возвращаются только те строки, где значение ключа в обеих таблицах совпадает.

### LEFT JOIN (левое объединение):

`LEFT JOIN` возвращает все строки из левой (первой) таблицы и соответствующие строки из правой (второй) таблицы.
Если для строки в левой таблице нет соответствующих строк в правой таблице, то для соответствующих столбцов правой таблицы будут возвращены `NULL` значения.
Левая таблица является сохраняющейся (`preserved`) таблицей, а правая таблица - таблицей, которая может содержать `NULL` значения.

### RIGHT JOIN (правое объединение):

`RIGHT JOIN` возвращает все строки из правой (второй) таблицы и соответствующие строки из левой (первой) таблицы.
Если для строки в правой таблице нет соответствующих строк в левой таблице, то для соответствующих столбцов левой таблицы будут возвращены `NULL` значения.
Правая таблица является сохраняющейся (preserved) таблицей, а левая таблица - таблицей, которая может содержать `NULL` значения.

### FULL JOIN (полное объединение):

```FULL JOIN``` возвращает все строки из обеих таблиц.
Если для строки в одной таблице нет соответствующей строки в другой таблице, то для соответствующих столбцов будет возвращено ```NULL``` значение.
Результатом ```FULL JOIN``` является объединение строк из обеих таблиц, где некоторые значения могут быть `NULL`.