
# Функции с произвольным количеством аргументов. \*args  и \*\*kwargs

## Каскадное присваивание и упаковка значений

Вы уже знаете, что в python присутствует опция *каскадного присваивания*. Используется она следующим образом:

```Python
x, y, z = 1, 2, 3
print(x, y, z) #значения присвоились соответствующим переменным
```

```Python
#Ошибочные записи с неравным количеством переменных и значений
x, y, z = 1, 2 
x, y = 1, 2, 3
```

Python  позволяет нам упаковывать значения в список при каскадном присваивании. Для этого используется оператор ```*```:

```Python
*a, = 1, 2, 3 #все значения попадают в список
print(a)
```

```Python
#два значения попадают в а и b, остальные отправляются в с
a, b, *c = 1, 2, 3, 4, 5, 6 
print(a, b, c)
```

```Python
#последние два значения попадают в b и c, значения до них попадают в а
*a, b, c = 1, 2, 3, 4, 5, 6 
print(a, b, c)
```

```Python
#догадайтесь, что произойдет здесь
a, *b, c = 1, 2, 3, 4, 5, 6 
print(a, b, c)
```

Нельзя использовать более одного оператора упаковки ```*``` в одном каскадоном присваивании:

```Python
#SyntaxError: two starred expressions in assignment
a, *b, *c = 1, 2, 3, 4, 5, 6 
print(a, b, c)
```

Также звездочка умеет не только упаковывать, но и распаковывать значения:

```Python
a = [1,2,3]
b = [*a,4,5,6]
print(b) # [1,2,3,4,5,6]
```

## Функции с произвольным количеством аргументов

В Python есть встроенные функции, которые принимают произвольное колчиство аргументов, например ```max()``` или ```min()```:

```Python
max_number = max(51,22,31,74,59,36,77,88,29)
min_number = min(-1, 32, 4, 36,77,88,29)
```

Как же создавать подобные функции? Итак, мы знаем о том, что оператор «звёздочка» в Python способен «вытаскивать» из объектов составляющие их элементы.

Это используется для создания функций с произвольным количеством аргументов. А именно, ```*args``` — это сокращение от «arguments» (аргументы), а ```**kwargs``` — сокращение от «keyword arguments» (именованные аргументы).

Каждая из этих конструкций используется для распаковки аргументов соответствующего типа, позволяя вызывать функции со списком аргументов переменной длины. Например — создадим функцию, которая умеет выводить результаты, набранные учеником в тесте:

```Python
def printScores(student, *scores):
   print(f"Student Name: {student}")
   for score in scores:
      print(score)
printScores("Jonathan",100, 95, 88, 92, 99)
```

Вывод:

```text
Student Name: Jonathan
100
95
88
92
99
```

Я не использовал при объявлении функции конструкцию ```*args```. Вместо неё у меня — ```*scores```. Нет ли тут ошибки? Ошибки здесь нет. Дело в том, что «args» — это всего лишь набор символов, которым принято обозначать аргументы. Самое главное тут — это оператор ```*```. А то, что именно идёт после него, особой роли не играет. Благодаря использованию ```*``` мы создали список позиционных аргументов на основе того, что было передано функции при вызове.

После того, как мы разобрались с ```*args```, с пониманием ```**kwargs``` проблем быть уже не должно. Имя, опять же, значения не имеет. Главное — это два символа ```**```. Благодаря им создаётся словарь, в котором содержатся именованные аргументы, переданные функции при её вызове.

```Python
def printPetNames(owner, **pets):
   print(f"Owner Name: {owner}")
   for pet,name in pets.items():
      print(f"{pet}: {name}")
printPetNames("Jonathan", dog="Brock", fish=["Larry", "Curly", "Moe"], turtle="Shelldon")
```

Вывод:

```text
Owner Name: Jonathan
dog: Brock
fish: ['Larry', 'Curly', 'Moe']
turtle: Shelldon
```

>Конструкцию ```**kwargs``` нельзя располагать до ```*args```. Если это сделать — будет выдано сообщение об ошибке

